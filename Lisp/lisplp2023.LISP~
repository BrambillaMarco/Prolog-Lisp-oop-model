;;; Definizione e manipolazione Hash-Table
(defparameter *classes-specs* (make-hash-table))
(defun add-class-spec (name class-spec)
  (setf (gethash name *classes-specs*) class-spec))
(defun get-class-spec (name)
  (gethash name *classes-specs*))

;;; Primitiva definizione classe
(defun def-class (class-name parents &rest parts)
  (cond
    ((not (symbolp class-name))
     (error "Error: nome classe non e' un simbolo"))
    ((not (listp parents))
     (error "Error: parent non e' una lista"))
    ((parents-control class-name parents)
     (error "Error: classe e parents con stesso nome"))
    ((not (check-parts parts))
     (error "Error: bad values formatting")))
  (let*
      ((genitori
	(if (null parents)
	    NIL
	    (remove-duplicates parents)))
       (formatted-slot (identify-method (formatta parts) nil)))
    (remhash class-name *classes-specs*)
    (add-class-spec class-name (list genitori formatted-slot)))
  class-name)



;;; Funzione parents-control controlla che tutti i parents
;;; siano simboli, che tutte i parents siano classi e che
;;; non ci siano parents con lo stesso class-name
(defun parents-control (class-name parents)
  (cond
    ((equal parents NIL)
     NIL)
    ((not (symbolp (first parents)))
     (error "Errore: i parents devono essere lista di simboli"))
    ((not (get-class-spec (first parents)))
     (error "Errore: classe genitore non esistente"))
    ((or (equal (first parents) class-name)
	 (parents-control class-name (rest parents))))))


;;; Funzione che controlla se ogni parte dell'input è una lista
;;; che inizia con 'fields o 'methods."
(defun check-parts (parts)
  ; Controlla se l'elenco delle parti è valido
  (and (valid-parts-list-p parts) 
       (<= (length parts) 2))) ; controllo massimo due parti   



;;; Verifica ricorsivamente se ogni parte nell'elenco è una 
;;; lista valida che inizia con 'fields o 'methods."
(defun valid-parts-list-p (parts)
  (if (null parts)
      t  ; Se non ci sono più parti, restituisce vero
      (and (valid-part-p (car parts))           
           (valid-parts-list-p (cdr parts)))))  


;;; Verifica se la parte è una lista che inizia 
;;; con 'fields o 'methods."
(defun valid-part-p (part)
  (and (listp part)
       ; Controlla se il primo elemento è 'fields o 'methods
       (or (equal (first part) 'fields)
           (equal (first part) 'methods))))  





;;; assumo che i methods vengano sempre dopo i fields
(defun formatta (&rest input)
  ;se ci sono sia fields che methods
  (cond ((and (equal (first (first input)) 'fields) 
           (equal (first (second input)) 'methods))
    (append (format-fields (first input)) (format-methods (second input))))
        ;se non ci sono fields
        ((equal (first (first input)) 'methods)
         (format-methods (first input)))
        ;se non ci sono methods
        ((and (equal (first (first input)) 'fields) 
           (= (length input) 1)) 
         (format-fields (first input)))
    ))


(defun format-fields (fields)
  (if (= (length fields) 1)
      nil
      (cons (list (first (cadr fields)) (second (cadr fields)) (if (third (cadr fields)) (third (cadr fields)) T))
            (format-fields (rest fields)))))

(defun format-methods (methods)
  (if (= (length methods) 1)
      nil
      (cons (list (first (cadr methods)) (list (second (cadr methods)) (third (cadr methods))))
            (format-methods (rest methods)))))




;;; Identifico i metodi e li tratto
(defun identify-method (values result)
  (cond
    ((null values)
     result)
    ((and (listp (second (first values)))
          (listp (third (first values))))
     (identify-method
      (rest values)
      (append result (list (list
                            (first (first values))
                            (process-method
                             (first (first values))
                             (second (first values))))))))
    ((not (null values))
     (identify-method (rest values)
		      (append result
			      (list (first values)))))))
    







;;; Funzione principale gestione metodi, ritorna un eval di una lambda
(defun process-method (method-name method-spec)
  (setf (fdefinition method-name)
	(lambda (this &rest args)
	  (apply (getv this method-name)
		 (append (list this) args))))
  (eval (rewrite-method-code method-name method-spec)))





;;; Riscrivo S-expression cosi da poter usare this
(defun rewrite-method-code (method-name method-spec)
  (if (symbolp method-name)
      (append
       (list 'lambda)
       (list(append (list 'this) (first method-spec)))
       (list (append '(progn) (rest method-spec))))))



;;; Primitiva getv
(defun getv (instance slot-name)
  (cond
    ((or (not (symbolp slot-name))
	 (null slot-name))
     (error "Errore: slot-name non valido"))
    ((not (equal 'oolinst (first instance)))
     (error "Errore: istanza non valida")))
  (let* ((is-in-instance
	  (recursive-getv-instance (third instance) slot-name)))
    (if is-in-instance
	(second is-in-instance)
	(let* ((is-in-tree
		(recursive-getv-tree (list (second instance))
				     slot-name)))
	  (if is-in-tree
	      (second is-in-tree)
	      (error "Errore: valore non valido"))))))



;;; Primitiva getvx, funge da trampolino
(defun getvx (instance &rest slot-name)
  (if (null slot-name)
      (error "Errore: slot-name+ vuoto"))
  (getvx-recursive instance slot-name))




;;; Ritorna una coppia di valori di istanza
(defun recursive-getv-instance (values slot-name)
  (cond
    ((equal values NIL)
     NIL)
    ((equal (first (first values)) slot-name)
     (first values))
    ((not (equal (first (first values)) slot-name))
     (recursive-getv-instance (rest values) slot-name))))



;;; Ritorna una coppia di valori di una classe in gerarchia
(defun recursive-getv-tree (classes slot-name)
  (let* ((is-in-level
	  (recursive-getv-instance
	   (second (get-class-spec (first classes)))
	   slot-name)))
    (cond
      ((equal classes  NIL)
       NIL)
      (is-in-level
       is-in-level)
      ((not is-in-level)
       (recursive-getv-tree
	(append (first (get-class-spec (first classes)))
		(rest classes))
	slot-name)))))



;;; Controllo valori e metodi di New 
(defun instance-check (class parameters)
  (if (equal parameters NIL)
      T
      (let* ((class-value (getv (list 'oolinst class NIL)
				(first(first parameters))))
	     (instance-value (if (listp (second (first parameters)))
				 (first (second (first parameters)))
				 (second (first parameters)))))
	(and
	 (or (and (functionp class-value) (equal '=> instance-value))
	     (and (not (functionp class-value))
		  (not (equal '=> instance-value))))
	 (instance-check class (rest parameters))))))



;;; Primitiva New
(defun new (class-name &rest parameters)
  (let* ((formatted (formatta parameters)))
    (cond
      ((not (symbolp class-name))
       (error "Errore: class-name non e' un simbolo"))
      ((values-control formatted)
       (error "Error: bad input format")))
    (if (and (get-class-spec class-name)
	     (instance-check class-name formatted))
	(list 'oolinst
	      class-name
	      (identify-method formatted nil))
	(error "Errore: classe o parametro incompatibile"))))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;forse non servono questi extract;;; da rivedere


;;; Funzione che estrae i fields dalle parts
(defun extract-fields (input)
  (let ((fields-part (assoc 'fields input)))
    (when fields-part
      (extract-pairs (cdr fields-part)))))

;;; Funzione che estrae i methods dalle parts
(defun extract-methods (input)
  (let ((methods-part (assoc 'methods input)))
    (when methods-part
      (extract-pairs (car (cdr methods-part))))))

;;; Funzione di appoggio a extract-fields/methods
;;; che estra ogni coppia
(defun extract-pairs (lst)
  (cond ((null lst) nil)
        ((listp (car lst)) (cons (car lst) (extract-pairs (cdr lst))))
        (t (extract-pairs (cdr lst)))))

